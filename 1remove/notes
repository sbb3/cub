// printf("%d\n", l); line_bytes 256 |  256/4 = 64 pixelsCount

// printf("%d\n", bpp); 32
// printf("%d\n", e); 0


/*
	scaling factor = little/bigger

	ex:
		sf =  minimapsize = windowsize
*/

/*
	360%360=0;
	0%360=0;
	42%360=42;
	-1%360=359
	-2%360=358



	Wall texture kaycht7
Texture stretching
Texture drawing direction n s w e
*/

/*
	360%360=0; 0%360=0; 362%360=2 42%360=42; -1%360=359
	return (angle % 360); // a<0 360-a < 360-360=0 <a-360
*/
/*
debug
*/

/**
 *  max pdir_y : 1, min pdir_y : -1
*/

/*

{
	A AND D KEYS

	// printf("left %d\n", left);
		// printf("right %d\n", right);
		// printf("up %d\n", up);
		// printf("down %d\n", down);
		// printf("pa %d\n", game->player_angle);
		// printf("na %d\n", new_angle_in_degrees);
		// printf("cos(na) %lf\n", cos(degree_to_radian(new_angle_in_degrees)));
		// printf("sin(na) %lf\n", sin(degree_to_radian(new_angle_in_degrees)));
		// printf("new_pos_x %d\n", new_pos_x);
		// printf("new_pos_y %d\n", new_pos_y);
		// printf("pos_x %d\n", game->pos_x);
		// printf("pos_y %d\n", game->pos_y);


		// I should x--; cos new_angle is already -
		// I should x++; cos new_angle is already +
		// I should y--; cos new_angle is already +
		// I should y++; cos new_angle is already -
		// refer to the drawing for more explanation

}

*/
// redraw
// re_draw



/*
set_the_texture_color_on_walls

* 4 (4 bytes) // convert from bits to bytes
color_pixel points to the first byte in the pixel (4 bytes)
main reason for doing the unsigned int, is there is no sign bit as in int and the guarantee size 4 bytes
*(unsigned int *)color_pixel = color; write the texture_color on the main image

*/


/* MINIMAP
scaled_pos_x = player_pos_x_in_minimap;

draw_arrow_line:
	pixel_x += cos(deg_2_rad(new_angle)); // dirX = direction, default to 0, range  [ -1 < 0 < 1 ]
	pixel_y -= sin(degree_to_radian(new_angle)); // dirY = direction, default to -1, range [ -1 < 0 < 1 ]

*/


/* paint.c
paint_walls_helper_function:
if (game->wall_height > game->window_height)
	{
		y = 0;
		end = game->window_height;
	}
	else
	{						// if there is only these 2 statements below, and the protection for resetting walltoppixel and wallbottompixel to 0 and game->window_height, it will start taking the color pixel from the texture at index 0, not dependng on the wallProjectedHeight
		y = game->wall_top_pixel; // y should always start with;
		end = game->wall_bottom_pixel;
	}


paint_walls:  // sizeX or width of the strip(column) will be 1, but since it is 1, there is no need to specify it here
while (y < end) // start drawing from the wall_top_pixel till wall_bottom_pixel , this distance is equal to projectedWallHeight
	{
		// calculate the offsetY
		// when projected_wall_height > game->window_height, wall_top_pixel will be negative and the sign -, then it will be positive
		game->texture_offset_y = (y - wall_top_pixel) * scaling_factor; // what pixel color to pick from the texture
		// is_north
		if (game->is_north && game->h_hit)
			color = get_the_color_from_north_texture(game); // hex color not rgb // the texture pixel color that will drawn on the globalImage
		// is_west
		else if (game->is_west && !game->h_hit)
			color = get_the_color_from_west_texture(game); // hex color not rgb // the texture pixel color that will drawn on the globalImage
		// is_south
		else if (game->is_south && game->h_hit)
			color = get_the_color_from_south_texture(game);
		// is_east texture
		else if (game->is_east && !game->h_hit)
			color = get_the_color_from_east_texture(game);

		set_the_texture_color_on_walls(game, startX, y, color);
		y++;
	}

*/


/* render.c
raycasting:
		// printf("%lf\n", game->ray_angle);
	game->ray_angle -= game->ray_angle_increment; // needed for drawing next ray // if it goes over 360, will reset to 0 + rayAngle

		// printf("%d\n", game->projected_wall_height);

	coordinates 0 0

deltaY  // deltaX | // first check if these coordinates are at wall, else increment them with ystep and xstep till u find a wall

*/


/* renderUtils.c
intersections_and_steps_horizontally

	// !!!!1 inf or nan
	if (tan(deg_2_rad(game->ray_angle) == 0))
			game->ray_angle -= degree_to_radian(1);

	// xstep on left down side will be positive so we turn it to negative same as the left up side, is already negative
	if (game->ray_left && game->xstep > 0)
			game->xstep *= -1;

	// xstep on right down side will be negative so we turn it to positive same as the right up side, is already positive
	if (game->ray_right && game->xstep < 0)
		game->xstep *= -1;

	// substract a pixel to check if nextY is in the wall
	if (game->ray_up)
		game->yinter--;


looking_for_wall_coordinates_vertically && looking_for_wall_coordinates_horizontally
	first check if these coordinates are at wall,
 else increment them with ystep and xstep till u find a wall


*/


/* renderUtils2.c
get_wall_top_bottom_pixels
// / when HALF_game->window_height < game->window_height, wall_top_pixel will be negative
	game->wall_top_pixel = HALF_game->window_height - (double)(game->projected_wall_height / 2); // wallHeight drawing start postion on the y-axis
	// if (game->wall_top_pixel < 0)
	// 	game->wall_top_pixel = 0;
	game->wall_bottom_pixel = HALF_game->window_height + (double)(game->projected_wall_height / 2);
	// (double) in case projected_wall_height low than 2, will not return a 0, but a double value like 0.22545
	// if (game->wall_bottom_pixel > game->window_height)
		// game->wall_bottom_pixel = game->window_height;

	// printf("t : %d\n", game->wall_top_pixel);
	// printf("b : %d\n", game->wall_bottom_pixel);


get_projected_wall_height
	if (game->projected_wall_height > game->window_height)
	{
		game->test2 = game->projected_wall_height;
		// game->projected_wall_height = game->window_height;
	}
	// printf("%lf\n", game->projected_wall_height);


get_the_short_distance
	game->distorted_ray_distance_to_wall = game->h_dist_to_wall;
		// !!!!! fix fishe eye : he red rays all have a different lenght, so would compute different wall heights for different vertical stripes, hence the rounded effect. The green rays on the right all have the same length, so will give the correct result. The same still apllies for when the player rotates (then the camera plane is no longer horizontal and the green lines will have different lengths, but still with a constant change between each) and the walls become diagonal but straight lines on the screen. This explanation is somewhat handwavy but gives the idea.
		// lodev fisheye explains it


		// printf("cd = %lf : rd = %lf : cos(ra - pa) = %lf\n", game->ray_distance, game->distorted_ray_distance_to_wall, cos(deg_2_rad(game->ray_angle - game->player_angle)));

*/
